"use strict";(self.webpackChunkrocketmq_docs=self.webpackChunkrocketmq_docs||[]).push([[9304],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=u(n),p=r,g=c["".concat(o,".").concat(p)]||c[p]||d[p]||l;return n?a.createElement(g,s(s({ref:t},m),{},{components:n})):a.createElement(g,s({ref:t},m))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=p;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[c]="string"==typeof e?e:r,s[1]=i;for(var u=2;u<l;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2033:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const l={},s="Metrics",i={unversionedId:"observability/01metrics",id:"version-5.0/observability/01metrics",title:"Metrics",description:"RocketMQ exposes the following metrics in Prometheus format. You can monitor your clusters with those metrics.",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-5.0/12-observability/01metrics.md",sourceDirName:"12-observability",slug:"/observability/01metrics",permalink:"/docs/observability/01metrics",draft:!1,editUrl:"https://github.com/apache/rocketmq-site/tree/new-official-website/versioned_docs/version-5.0/12-observability/01metrics.md",tags:[],version:"5.0",frontMatter:{},sidebar:"version-5.0/myAutogeneratedSidebar",previous:{title:"RocketMQ Promethus Exporter",permalink:"/docs/deploymentOperations/05Exporter"},next:{title:"Basic Best Practices",permalink:"/docs/bestPractice/01bestpractice"}},o={},u=[{value:"Details of metrics",id:"details-of-metrics",level:2},{value:"Metric types",id:"metric-types",level:3},{value:"Broker metrics",id:"broker-metrics",level:3},{value:"Producer metrics",id:"producer-metrics",level:3},{value:"Consumer metrics",id:"consumer-metrics",level:3},{value:"Background information",id:"background-information",level:2},{value:"Message accumulation scenarios",id:"message-accumulation-scenarios",level:3},{value:"PushConsumer consumption scenarios",id:"pushconsumer-consumption-scenarios",level:3}],m={toc:u},c="wrapper";function d(e){let{components:t,...l}=e;return(0,r.kt)(c,(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"metrics"},"Metrics"),(0,r.kt)("p",null,"RocketMQ exposes the following metrics in Prometheus format. You can monitor your clusters with those metrics."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Broker metrics"),(0,r.kt)("li",{parentName:"ul"},"Producer metrics"),(0,r.kt)("li",{parentName:"ul"},"Consumer metrics")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Version support: The following metrics for RocketMQ were introduced since 5.1.0 and only support the broker.")),(0,r.kt)("h2",{id:"details-of-metrics"},"Details of metrics"),(0,r.kt)("h3",{id:"metric-types"},"Metric types"),(0,r.kt)("p",null,"The standard for defining metrics in RocketMQ complies with that for defining the metrics in open source Prometheus. The metric types that RocketMQ offers include counters, gauges, and histograms. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://prometheus.io/docs/concepts/metric_types/"},"METRIC TYPES"),"."),(0,r.kt)("h3",{id:"broker-metrics"},"Broker metrics"),(0,r.kt)("p",null,"The following table describes the labels of the metrics that are related to the Message Queue for Apache RocketMQ broker."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cluster: RocketMQ cluster name."),(0,r.kt)("li",{parentName:"ul"},"node_type: the type of service node, whitch includes the following:proxy,broker,nameserver."),(0,r.kt)("li",{parentName:"ul"},"node_id: the ID of the service node."),(0,r.kt)("li",{parentName:"ul"},"topic: the topic of RocketMQ."),(0,r.kt)("li",{parentName:"ul"},"message_type: the type of a message, which includes the following:",(0,r.kt)("br",null),"normal:normal messages;",(0,r.kt)("br",null),"fifo:ordered messages;",(0,r.kt)("br",null),"transaction:Transactional messages;",(0,r.kt)("br",null),"delay:scheduled or delayed messages."),(0,r.kt)("li",{parentName:"ul"},"consumer_group: the ID of the consumer group.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Unit"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Label"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"counter"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_messages_in_total"),(0,r.kt)("td",{parentName:"tr",align:null},"count"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of messages that are produced."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic,message_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"counter"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_messages_out_total"),(0,r.kt)("td",{parentName:"tr",align:null},"count"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of messages that are consumed."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"counter"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_throughput_in_total"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"The write throughput that are produced."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic,message_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"counter"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_throughput_out_total"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"The read throughput that are produced."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"histogram"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_message_size"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"The distribution of message sizes. This metric is counted only when messages are sent. The following shows the distribution ranges:",(0,r.kt)("br",null),"le_1_kb: \u2264 1 KB",(0,r.kt)("br",null)," le_4_kb: \u2264 4 KB",(0,r.kt)("br",null),"le_512_kb: \u2264 512 KB",(0,r.kt)("br",null),"le_1_mb: \u2264 1 MB",(0,r.kt)("br",null),"le_2_mb: \u2264 2 MB",(0,r.kt)("br",null),"le_4_mb: \u2264 4 MB",(0,r.kt)("br",null),"le_overflow: > 4 MB"),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic,message_type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_consumer_ready_messages"),(0,r.kt)("td",{parentName:"tr",align:null},"count"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of ready messages."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_consumer_inflight_messages"),(0,r.kt)("td",{parentName:"tr",align:null},"count"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of inflight messages."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_consumer_queueing_latency"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"Ready messages queueing delay time."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_consumer_lag_latency"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"The delayed time before messages are consumed."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"counter"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_send_to_dlq_messages_total"),(0,r.kt)("td",{parentName:"tr",align:null},"count"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of messages that are sent to the dead-letter queue."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,topic, consumer_group")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"histogram"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_rpc_latency"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"The rpc call latency"),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_typ,node_id,protocol_type,request_code,response_code")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_storage_message_reserve_time"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"Message retention time."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_storage_dispatch_behind_bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"Undispatched message size."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_storage_flush_behind_bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"Unflushed messsage size."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_thread_pool_wartermark"),(0,r.kt)("td",{parentName:"tr",align:null},"count"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of tasks queued in the thread pool."),(0,r.kt)("td",{parentName:"tr",align:null},"cluster,node_type,node_id,name")))),(0,r.kt)("h3",{id:"producer-metrics"},"Producer metrics"),(0,r.kt)("p",null,"The following table describes the labels of the metrics that are related to the producers in Message Queue for Apache RocketMQ."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cluster: RocketMQ cluster name."),(0,r.kt)("li",{parentName:"ul"},"node_type: the type of service node, whitch includes the following:proxy,broker,nameserver."),(0,r.kt)("li",{parentName:"ul"},"node_id: the ID of the service node."),(0,r.kt)("li",{parentName:"ul"},"topic: the topic of Message Queue for Apache RocketMQ."),(0,r.kt)("li",{parentName:"ul"},"message_type: the type of a message, which includes the following:",(0,r.kt)("br",null),"normal:normal messages;",(0,r.kt)("br",null),"fifo:ordered messages;",(0,r.kt)("br",null),"transaction:Transactional messages;",(0,r.kt)("br",null),"delay:scheduled or delayed messages."),(0,r.kt)("li",{parentName:"ul"},"client_id: the ID of the client."),(0,r.kt)("li",{parentName:"ul"},"invocation_status: the result of the API call for sending messages, which includes success and failure.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Unit"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Label"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Histogram"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_send_cost_time"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"The distribution of production API call time. The following shows the distribution ranges: ",(0,r.kt)("br",null),"le_1_ms ",(0,r.kt)("br",null),"le_5_ms",(0,r.kt)("br",null),"le_10_ms",(0,r.kt)("br",null),"le_20_ms ",(0,r.kt)("br",null),"le_50_ms ",(0,r.kt)("br",null),"le_200_ms",(0,r.kt)("br",null),"le_500_ms ",(0,r.kt)("br",null),"le_overflow"),(0,r.kt)("td",{parentName:"tr",align:null},"topic,client_id,invocation_status")))),(0,r.kt)("h3",{id:"consumer-metrics"},"Consumer metrics"),(0,r.kt)("p",null,"The following table describes the labels of the metrics that are related to the consumers in Message Queue for Apache RocketMQ."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"topic: the topic of Message Queue for Apache RocketMQ."),(0,r.kt)("li",{parentName:"ul"},"consumer_group: the ID of the consumer group."),(0,r.kt)("li",{parentName:"ul"},"client_id: the ID of the client."),(0,r.kt)("li",{parentName:"ul"},"invocation_status: the result of the API call for sending messages, which includes success and failure.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Unit"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Label"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Histogram"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_process_time"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"The distribution of message process time.The following shows the distribution ranges: ",(0,r.kt)("br",null),"le_1_ms ",(0,r.kt)("br",null),"le_5_ms \xa0",(0,r.kt)("br",null),"le_10_ms",(0,r.kt)("br",null),"le_100_ms ",(0,r.kt)("br",null),"le_10000_ms",(0,r.kt)("br",null),"le_60000_ms ",(0,r.kt)("br",null),"le_overflow"),(0,r.kt)("td",{parentName:"tr",align:null},"topic,consumer_group,client_id,invocation_status")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_consumer_cached_messages"),(0,r.kt)("td",{parentName:"tr",align:null},"message"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of messages in the local buffer queue of PushConsumer."),(0,r.kt)("td",{parentName:"tr",align:null},"topic,consumer_group,client_id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"gauge"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_consumer_cached_bytes"),(0,r.kt)("td",{parentName:"tr",align:null},"byte"),(0,r.kt)("td",{parentName:"tr",align:null},"The total size of messages in the local buffer queue of PushConsumer."),(0,r.kt)("td",{parentName:"tr",align:null},"topic,consumer_group,client_id")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Histogram"),(0,r.kt)("td",{parentName:"tr",align:null},"rocketmq_await_time"),(0,r.kt)("td",{parentName:"tr",align:null},"millisecond"),(0,r.kt)("td",{parentName:"tr",align:null},"The distribution of queuing time for messages in the local buffer queue of PushConsumer. The following shows the distribution ranges:",(0,r.kt)("br",null),"le_1_ms",(0,r.kt)("br",null)," le_5_ms",(0,r.kt)("br",null),"le_20_ms",(0,r.kt)("br",null),"le_100_ms ",(0,r.kt)("br",null),"le_1000_ms",(0,r.kt)("br",null)," le_5000_ms ",(0,r.kt)("br",null),"le_10000_ms",(0,r.kt)("br",null),"le_overflow"),(0,r.kt)("td",{parentName:"tr",align:null},"topic,consumer_group,client_id")))),(0,r.kt)("h2",{id:"background-information"},"Background information"),(0,r.kt)("p",null,"RocketMQ defines metrics based on the following business scenarios."),(0,r.kt)("h3",{id:"message-accumulation-scenarios"},"Message accumulation scenarios"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"rocketmq queue meesage stuatus",src:n(34598).Z,width:"851",height:"243"}),(0,r.kt)("br",null),"The above figure shows the number and duration of messages in different stages. By monitoring these metrics, you can determine whether the business consumption is abnormal. The following table describes the meaning of these metrics and the formulas that are used to calculate these metrics."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Formula"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Inflight messages"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of messages being processed by consumer but not acked yet"),(0,r.kt)("td",{parentName:"tr",align:null},"Offset of the latest pulled message - Offset of the latest committed message")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ready messages"),(0,r.kt)("td",{parentName:"tr",align:null},"The number of messages that are ready for consumption."),(0,r.kt)("td",{parentName:"tr",align:null},"Maximum offset - Offset of the latest pulled message")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ready time"),(0,r.kt)("td",{parentName:"tr",align:null},"normal message or ordered message:the time when the message is stored to the broker. \xa0",(0,r.kt)("br",null)," Scheduled message:timing end time. ",(0,r.kt)("br",null)," \xa0Transactional message: transaction commit time."),(0,r.kt)("td",{parentName:"tr",align:null},"--")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ready message queue time"),(0,r.kt)("td",{parentName:"tr",align:null},"The time interval between the ready time of the earliest ready message and the current time. This time reflects the timeliness of consumers pulling messages."),(0,r.kt)("td",{parentName:"tr",align:null},"Current time - Ready time of the earliest ready message")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Consumer lag time"),(0,r.kt)("td",{parentName:"tr",align:null},"The time difference between the ready time of the earliest unacked message and the current moment.",(0,r.kt)("br",null),"This time reflects the timeliness of the consumer to complete message processing."),(0,r.kt)("td",{parentName:"tr",align:null},"Current time - Ready time of the earliest unacked message")))),(0,r.kt)("h3",{id:"pushconsumer-consumption-scenarios"},"PushConsumer consumption scenarios"),(0,r.kt)("p",null,"In PushConsumer, real-time message processing capability is implemented based on the typical Reactor thread model inside the SDK.As shown below, the SDK has a built-in long polling thread that asynchronously pulls messages into the SDK's built-in buffer queue and then separately commits them to the consumer thread, triggering the listener to execute the local consumption logic.",(0,r.kt)("br",null),(0,r.kt)("img",{alt:"PushConsumer client",src:n(63446).Z,width:"681",height:"321"}),(0,r.kt)("br",null),"The metrics of local buffer queues in the PushConsumer scenario are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Number of messages in the local buffer queue: Total number of messages in the local buffer queue."),(0,r.kt)("li",{parentName:"ul"},"Message size in the local buffer queue: The sum of all message sizes in the local buffer queue."),(0,r.kt)("li",{parentName:"ul"},"Message waiting time: the time that the message is temporarily cached in the local buffer queue waiting to be processed.")))}d.isMDXComponent=!0},34598:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/message-accumulation-4a033c0e12019e8da39e570e02247318.png"},63446:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/pushconsumer-consumption-1e24bd7ab8e28a1f165635bd5a49637f.png"}}]);